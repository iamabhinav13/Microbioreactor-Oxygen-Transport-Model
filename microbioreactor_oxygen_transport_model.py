# -*- coding: utf-8 -*-
"""Microbioreactor Oxygen Transport Model

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IS3pqnll5AllyRxBiZIycNCHCymXH68S
"""

import numpy as np
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

def calculate_steady_state(z_grid, C_star, OUR, params):
    """
    Calculates the quasi-steady state concentration profile based on Eq. (15)
    from Hong and Braatz (2021).
    """
    # Unpack parameters
    d, L, Dp, Dw, eta, Kp, Kw = params['d'], params['L'], params['Dp'], params['Dw'], params['eta'], params['Kp'], params['Kw']

    C_ss = np.zeros_like(z_grid)
    interface_idx = np.where(z_grid >= 0)[0][0]
    K = Kw / Kp

    # Region 1: PDMS Membrane (-d <= z < 0)
    for i in range(interface_idx):
        z = z_grid[i]
        C_ss[i] = Kp * C_star - OUR * L * (d + z) / Dp

    # Region 2: Growth Well (0 <= z <= L)
    for i in range(interface_idx, len(z_grid)):
        z = z_grid[i]
        term1 = (K * L * d / Dp)
        term2 = (L**2 - (L - z)**2) / (2 * eta * Dw)
        C_ss[i] = Kw * C_star - OUR * (term1 + term2)

    # Ensure concentration is physically realistic (non-negative)
    return np.maximum(0, C_ss)


def microbioreactor_pde_model(t, C, z, params):
    """
    Represents the spatial PDE for oxygen transport as a system of ODEs
    using the method of lines. This version includes corrections for stability.
    """
    # Unpack parameters
    d, L, Dp, Dw, eta, Kp, Kw = params['d'], params['L'], params['Dp'], params['Dw'], params['eta'], params['Kp'], params['Kw']
    OUR = params['OUR_func'](t)

    N = len(z)
    dCdt = np.zeros(N)
    dz = z[1] - z[0] # Assume uniform grid

    interface_idx = np.where(z >= 0)[0][0]

    # --- Boundary Condition at z = -d (External Gas) is handled in the wrapper ---
    dCdt[0] = 0

    # --- Region 1: PDMS Membrane (-d < z < 0) ---
    for i in range(1, interface_idx):
        flux_in = Dp * (C[i] - C[i-1]) / dz
        flux_out = Dp * (C[i+1] - C[i]) / dz
        dCdt[i] = (flux_out - flux_in) / dz

    # --- Corrected Interface Condition at z = 0 ---
    K = Kw / Kp
    resistance_pdms = dz / (2 * Dp)
    resistance_well = dz / (2 * eta * Dw)
    flux_at_interface = (C[interface_idx-1] - C[interface_idx]/K) / (resistance_pdms + resistance_well/K)

    # Update for node just before interface
    flux_in_at_minus_1 = Dp * (C[interface_idx-1] - C[interface_idx-2]) / dz
    dCdt[interface_idx-1] = (flux_at_interface - flux_in_at_minus_1) / dz

    # Update for node at interface (in growth well)
    flux_out_at_plus_1 = eta * Dw * (C[interface_idx+1] - C[interface_idx]) / dz
    dCdt[interface_idx] = ((flux_out_at_plus_1 - flux_at_interface) / dz) - OUR


    # --- Region 2: Growth Well (0 < z < L) ---
    for i in range(interface_idx + 1, N - 1):
        flux_in = eta * Dw * (C[i] - C[i-1]) / dz
        flux_out = eta * Dw * (C[i+1] - C[i]) / dz
        dCdt[i] = ((flux_out - flux_in) / dz) - OUR

    # --- Corrected Boundary Condition at z = L (Sensor Wall - no flux) ---
    dCdt[N-1] = eta * Dw * 2 * (C[N-2] - C[N-1]) / (dz**2) - OUR

    return dCdt

def kla_model(t, C_L, params_kla):
    """
    Lumped parameter kLa model from Eq. (13) of Hong and Braatz (2021).
    """
    kla, Kw, OUR_func, C_star_func = params_kla['kla'], params_kla['Kw'], params_kla['OUR_func'], params_kla['C_star_func']
    OUR = OUR_func(t)
    C_star = C_star_func(t)
    C_saturated = Kw * C_star
    dCdt = kla * (C_saturated - C_L) - OUR
    return dCdt


def run_main_simulation(params):
    """Runs and plots the primary 3D and 2D simulations."""
    print("Running primary simulation...")
    # Define spatial grid
    Nz = 101
    # Corrected: Use a single uniform grid for the entire domain
    z_grid = np.linspace(-params['d'], params['L'], Nz)

    # Define time-dependent inputs
    def our_function(t):
        q0 = 20; X0 = 0.1; mu = 0.5
        # Corrected units: q0(mmol/g/h), X0(g/L), mu(h^-1) -> OUR(mM/s)
        return (q0 / 3600) * X0 * np.exp((mu / 3600) * t)

    def c_star_function(t):
        return 250.0 if t < 5 else 200.0

    params['OUR_func'] = our_function
    params['C_star_func'] = c_star_function

    # Initial Conditions
    C0 = calculate_steady_state(z_grid, c_star_function(0), our_function(0), params)

    # Solve the ODE system
    t_span = [0, 60]
    t_eval = np.linspace(t_span[0], t_span[1], 150)

    def ode_system_wrapper(t, C_internal, z, params):
        C_full = np.zeros(len(z))
        C_full[0] = params['Kp'] * params['C_star_func'](t)
        C_full[1:] = C_internal
        dCdt_full = microbioreactor_pde_model(t, C_full, z, params)
        return dCdt_full[1:]

    sol = solve_ivp(
        ode_system_wrapper, t_span, C0[1:], args=(z_grid, params),
        dense_output=True, t_eval=t_eval, method='BDF'
    )

    # Reconstruct and process solution
    C_solution = np.zeros((len(z_grid), len(sol.t)))
    for i, t_val in enumerate(sol.t):
        C_solution[0, i] = params['Kp'] * params['C_star_func'](t_val)
    C_solution[1:, :] = sol.y

    C_plot = np.zeros_like(C_solution)
    interface_idx_plot = np.where(z_grid >= 0)[0][0]
    C_plot[:interface_idx_plot, :] = C_solution[:interface_idx_plot, :] / params['Kp']
    C_plot[interface_idx_plot:, :] = C_solution[interface_idx_plot:, :] / params['Kw']

    # --- Plotting Results ---
    # 1. 3D Surface Plot
    fig = plt.figure(figsize=(12, 8))
    ax = fig.add_subplot(111, projection='3d')
    T, Z = np.meshgrid(t_eval, z_grid * 1e4)
    surf = ax.plot_surface(T, Z, C_plot, cmap='viridis', rstride=1, cstride=1, edgecolor='none')
    ax.set_xlabel('Time (s)'); ax.set_ylabel('Position z (microns)'); ax.set_zlabel('DO (% Air Sat)')
    ax.set_title('Spatiotemporal DO Profile in Microbioreactor'); ax.view_init(elev=30, azim=-120)
    fig.colorbar(surf, shrink=0.5, aspect=5, label='% Air Sat'); plt.show()

    # 2. 2D Plot of concentrations at key locations
    plt.figure(figsize=(10, 6))
    plt.plot(t_eval, C_plot[0, :], 'r-', label=f'z = {-params["d"]*1e4:.0f} µm (Gas Interface)')
    plt.plot(t_eval, C_plot[interface_idx_plot, :], 'g--', label='z = 0 µm (Interface)')
    plt.plot(t_eval, C_plot[-1, :], 'b-.', label=f'z = {params["L"]*1e4:.0f} µm (Sensor)')
    plt.title('DO Concentration at Key Locations'); plt.xlabel('Time (s)'); plt.ylabel('DO (% Air Sat)')
    plt.legend(); plt.grid(True); plt.ylim(bottom=0); plt.show()


def run_comparison_simulation(params):
    """
    Runs a simulation comparing the full PDE model with the lumped kLa model,
    replicating the analysis from Fig. 2 of Hong and Braatz (2021).
    """
    print("\nRunning comparison simulation (PDE vs. kLa)...")
    # --- Shared Parameters ---
    d, L, Dp, Dw, eta, Kp, Kw = params['d'], params['L'], params['Dp'], params['Dw'], params['eta'], params['Kp'], params['Kw']
    K = Kw/Kp

    # Calculate steady-state kLa from Eq. (16)
    kla_val = 1 / ( (K*L*d/Dp) + (L**2 / (2*eta*Dw)) )
    print(f"Calculated kLa value: {kla_val:.4f} s^-1")
    params_kla = {'kla': kla_val, 'Kw': Kw}

    # --- Simulation Scenarios ---
    scenarios = {
        "Slow Changes (60s)": {'period': 60, 't_end': 120},
        "Fast Changes (10s)": {'period': 10, 't_end': 60}
    }

    fig, axes = plt.subplots(2, 1, figsize=(10, 10))

    # Define OUR function outside the loop for consistency
    def our_function_static(t):
        q0 = 20; X0 = 0.1; mu = 0.5
        # This is the OUR at t=0, used for the comparison simulation
        return (q0 / 3600) * X0 * np.exp((mu / 3600) * 0)

    for i, (title, config) in enumerate(scenarios.items()):
        ax = axes[i]
        period = config['period']
        t_span = [0, config['t_end']]
        t_eval = np.linspace(t_span[0], t_span[1], 500)

        def c_star_periodic(t):
            return 250.0 if (t // period) % 2 == 0 else 200.0

        const_our = our_function_static(0)
        def our_periodic(t): return const_our

        params['OUR_func'] = our_periodic
        params['C_star_func'] = c_star_periodic
        params_kla['OUR_func'] = our_periodic
        params_kla['C_star_func'] = c_star_periodic

        # --- Run PDE Model ---
        Nz = 101
        # Corrected: Use a single uniform grid for the entire domain
        z_grid = np.linspace(-d, L, Nz)
        C0_pde = calculate_steady_state(z_grid, c_star_periodic(0), our_periodic(0), params)

        def ode_wrapper(t, C_int, z, p):
            C_full = np.zeros(len(z)); C_full[0] = p['Kp'] * p['C_star_func'](t); C_full[1:] = C_int
            return microbioreactor_pde_model(t, C_full, z, p)[1:]

        # Corrected: Added method='BDF' for robustness with stiff systems
        sol_pde = solve_ivp(ode_wrapper, t_span, C0_pde[1:], args=(z_grid, params), t_eval=t_eval, method='BDF')
        C_sensor_pde = (sol_pde.y[-1, :] / Kw)

        # --- Run kLa Model ---
        C0_kla = C0_pde[-1]
        sol_kla = solve_ivp(kla_model, t_span, [C0_kla], args=(params_kla,), t_eval=t_eval)
        C_sensor_kla = sol_kla.y[0] / Kw

        # --- Plotting ---
        ax.plot(t_eval, C_sensor_pde, 'r-', label='PDE Model (FFT in paper)')
        ax.plot(t_eval, C_sensor_kla, 'b-', label='kLa Model')
        ax.set_title(f'Model Comparison: {title}')
        ax.set_xlabel('Time (s)'); ax.set_ylabel('DO at Sensor (% Air Sat)')
        ax.grid(True, linestyle=':')
        for t_change in np.arange(period, t_span[1], period):
             ax.axvline(x=t_change, color='k', linestyle=':', linewidth=0.8)
        ax.legend(); ax.set_ylim(bottom=0)

    plt.tight_layout(); plt.show()


if __name__ == "__main__":
    # --- Model Parameters from Hong and Braatz (2021) ---
    base_params = {
        'd': 70e-4, 'L': 500e-4, 'Dp': 2.14e-5, 'Dw': 2.19e-5,
        'eta': 13.0, 'Kp': 0.9, 'Kw': 0.27,
    }

    # Run the main simulation showing the 3D profile
    run_main_simulation(base_params.copy())

    # Run the comparison simulation showing PDE vs kLa models
    run_comparison_simulation(base_params.copy())